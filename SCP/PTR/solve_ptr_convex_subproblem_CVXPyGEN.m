function [x_sol, u_sol, p_sol, sol_info, problem] = solve_ptr_convex_subproblem_CVXPyGEN(prob, ptr_ops, x_ref, u_ref, p_ref, problem)
%SOLVE_PTR_CONVEX_SUBPROBLEM_NO_P_CVXPYGEN Summary of this function goes here
%   Detailed explanation goes here

t1 = tic;

% Solve
if prob.Name == "Earth2Ast_fixed"
    if prob.u_hold == "ZOH"
        error("ZOH CVXPyGEN for Earth2Ast_fixed not implemented")
        %[X_py, U_py, eta_py, V_py, v_0_py, v_N_py, solve_status_py, problem] = pyrunfile("Ast2Ast_fixed_ZOH.py", ["X_sol", "U_sol", "eta", "V", "v_0", "v_N", "solve_status", "problem"], x_ref = x_ref, u_ref = u_ref, x_0 = prob.x0, x_f = prob.xf, A_k = prob.disc.A_k, B_k = prob.disc.B_k, c_k = prob.disc.c_k, params = prob.params, N = prob.N - 1, delta_t = prob.tf / (prob.N - 1), w_vc = ptr_ops.w_vc, w_tr = ptr_ops.w_tr, problem = problem);
    elseif prob.u_hold == "FOH"
        [U, V, v_0, v_N, eta, X, p] = cpg_solve_wrap_Earth2Ast(... % ADD SOLVE STATUS
            prob.disc.A_k(:, :, 1), prob.disc.B_minus_k(:, :, 1), prob.disc.B_plus_k(:, :, 1), ...
            prob.disc.c_k(:), ...
            prob.disc.A_k(:, :, 2), prob.disc.B_minus_k(:, :, 2), prob.disc.B_plus_k(:, :, 2), ...
            prob.disc.A_k(:, :, 3), prob.disc.B_minus_k(:, :, 3), prob.disc.B_plus_k(:, :, 3), ...
            prob.disc.A_k(:, :, 4), prob.disc.B_minus_k(:, :, 4), prob.disc.B_plus_k(:, :, 4), ...
            prob.disc.A_k(:, :, 5), prob.disc.B_minus_k(:, :, 5), prob.disc.B_plus_k(:, :, 5), ...
            prob.disc.A_k(:, :, 6), prob.disc.B_minus_k(:, :, 6), prob.disc.B_plus_k(:, :, 6), ...
            prob.disc.A_k(:, :, 7), prob.disc.B_minus_k(:, :, 7), prob.disc.B_plus_k(:, :, 7), ...
            prob.disc.A_k(:, :, 8), prob.disc.B_minus_k(:, :, 8), prob.disc.B_plus_k(:, :, 8), ...
            prob.disc.A_k(:, :, 9), prob.disc.B_minus_k(:, :, 9), prob.disc.B_plus_k(:, :, 9), ...
            prob.disc.A_k(:, :, 10), prob.disc.B_minus_k(:, :, 10), prob.disc.B_plus_k(:, :, 10), ...
            prob.disc.A_k(:, :, 11), prob.disc.B_minus_k(:, :, 11), prob.disc.B_plus_k(:, :, 11), ...
            prob.disc.A_k(:, :, 12), prob.disc.B_minus_k(:, :, 12), prob.disc.B_plus_k(:, :, 12), ...
            prob.disc.A_k(:, :, 13), prob.disc.B_minus_k(:, :, 13), prob.disc.B_plus_k(:, :, 13), ...
            prob.disc.A_k(:, :, 14), prob.disc.B_minus_k(:, :, 14), prob.disc.B_plus_k(:, :, 14), ...
            prob.x0, prob.xf, x_ref, u_ref); % Technically should pass in delta_t too but just scales objective function...
    end
elseif prob.Name == "Ast2Earth_fixed"
    if prob.u_hold == "ZOH"
        error("ZOH CVXPyGEN for Ast2Earth_fixed not implemented")
        %[X_py, U_py, eta_py, V_py, v_0_py, v_N_py, solve_status_py, problem] = pyrunfile("Ast2Ast_fixed_ZOH.py", ["X_sol", "U_sol", "eta", "V", "v_0", "v_N", "solve_status", "problem"], x_ref = x_ref, u_ref = u_ref, x_0 = prob.x0, x_f = prob.xf, A_k = prob.disc.A_k, B_k = prob.disc.B_k, c_k = prob.disc.c_k, params = prob.params, N = prob.N - 1, delta_t = prob.tf / (prob.N - 1), w_vc = ptr_ops.w_vc, w_tr = ptr_ops.w_tr, problem = problem);
    elseif prob.u_hold == "FOH"
        [U, V, v_0, v_N, eta, X, p] = cpg_solve_wrap_Ast2Earth(... % ADD SOLVE STATUS
            prob.disc.A_k(:, :, 1), prob.disc.B_minus_k(:, :, 1), prob.disc.B_plus_k(:, :, 1), ...
            prob.disc.c_k(:), ...
            prob.disc.A_k(:, :, 2), prob.disc.B_minus_k(:, :, 2), prob.disc.B_plus_k(:, :, 2), ...
            prob.disc.A_k(:, :, 3), prob.disc.B_minus_k(:, :, 3), prob.disc.B_plus_k(:, :, 3), ...
            prob.disc.A_k(:, :, 4), prob.disc.B_minus_k(:, :, 4), prob.disc.B_plus_k(:, :, 4), ...
            prob.disc.A_k(:, :, 5), prob.disc.B_minus_k(:, :, 5), prob.disc.B_plus_k(:, :, 5), ...
            prob.disc.A_k(:, :, 6), prob.disc.B_minus_k(:, :, 6), prob.disc.B_plus_k(:, :, 6), ...
            prob.disc.A_k(:, :, 7), prob.disc.B_minus_k(:, :, 7), prob.disc.B_plus_k(:, :, 7), ...
            prob.disc.A_k(:, :, 8), prob.disc.B_minus_k(:, :, 8), prob.disc.B_plus_k(:, :, 8), ...
            prob.disc.A_k(:, :, 9), prob.disc.B_minus_k(:, :, 9), prob.disc.B_plus_k(:, :, 9), ...
            prob.disc.A_k(:, :, 10), prob.disc.B_minus_k(:, :, 10), prob.disc.B_plus_k(:, :, 10), ...
            prob.disc.A_k(:, :, 11), prob.disc.B_minus_k(:, :, 11), prob.disc.B_plus_k(:, :, 11), ...
            prob.disc.A_k(:, :, 12), prob.disc.B_minus_k(:, :, 12), prob.disc.B_plus_k(:, :, 12), ...
            prob.disc.A_k(:, :, 13), prob.disc.B_minus_k(:, :, 13), prob.disc.B_plus_k(:, :, 13), ...
            prob.disc.A_k(:, :, 14), prob.disc.B_minus_k(:, :, 14), prob.disc.B_plus_k(:, :, 14), ...
            prob.x0, prob.xf, x_ref, u_ref); % Technically should pass in delta_t too but just scales objective function...
    end
elseif prob.Name == "Ast2Earth_fixedmf"
    if prob.u_hold == "ZOH"
        error("ZOH CVXPyGEN for Ast2Earth_fixedmf not implemented")
        %[X_py, U_py, eta_py, V_py, v_0_py, v_N_py, solve_status_py, problem] = pyrunfile("Ast2Ast_fixed_ZOH.py", ["X_sol", "U_sol", "eta", "V", "v_0", "v_N", "solve_status", "problem"], x_ref = x_ref, u_ref = u_ref, x_0 = prob.x0, x_f = prob.xf, A_k = prob.disc.A_k, B_k = prob.disc.B_k, c_k = prob.disc.c_k, params = prob.params, N = prob.N - 1, delta_t = prob.tf / (prob.N - 1), w_vc = ptr_ops.w_vc, w_tr = ptr_ops.w_tr, problem = problem);
    elseif prob.u_hold == "FOH"
        [U, V, v_0, v_N, eta, X, p] = cpg_solve_wrap_Ast2Earth_fixedmf(... % ADD SOLVE STATUS
            prob.disc.A_k(:, :, 1), prob.disc.B_minus_k(:, :, 1), prob.disc.B_plus_k(:, :, 1), ...
            prob.disc.c_k(:), ...
            prob.disc.A_k(:, :, 2), prob.disc.B_minus_k(:, :, 2), prob.disc.B_plus_k(:, :, 2), ...
            prob.disc.A_k(:, :, 3), prob.disc.B_minus_k(:, :, 3), prob.disc.B_plus_k(:, :, 3), ...
            prob.disc.A_k(:, :, 4), prob.disc.B_minus_k(:, :, 4), prob.disc.B_plus_k(:, :, 4), ...
            prob.disc.A_k(:, :, 5), prob.disc.B_minus_k(:, :, 5), prob.disc.B_plus_k(:, :, 5), ...
            prob.disc.A_k(:, :, 6), prob.disc.B_minus_k(:, :, 6), prob.disc.B_plus_k(:, :, 6), ...
            prob.disc.A_k(:, :, 7), prob.disc.B_minus_k(:, :, 7), prob.disc.B_plus_k(:, :, 7), ...
            prob.disc.A_k(:, :, 8), prob.disc.B_minus_k(:, :, 8), prob.disc.B_plus_k(:, :, 8), ...
            prob.disc.A_k(:, :, 9), prob.disc.B_minus_k(:, :, 9), prob.disc.B_plus_k(:, :, 9), ...
            prob.disc.A_k(:, :, 10), prob.disc.B_minus_k(:, :, 10), prob.disc.B_plus_k(:, :, 10), ...
            prob.disc.A_k(:, :, 11), prob.disc.B_minus_k(:, :, 11), prob.disc.B_plus_k(:, :, 11), ...
            prob.disc.A_k(:, :, 12), prob.disc.B_minus_k(:, :, 12), prob.disc.B_plus_k(:, :, 12), ...
            prob.disc.A_k(:, :, 13), prob.disc.B_minus_k(:, :, 13), prob.disc.B_plus_k(:, :, 13), ...
            prob.disc.A_k(:, :, 14), prob.disc.B_minus_k(:, :, 14), prob.disc.B_plus_k(:, :, 14), ...
            prob.x0, prob.xf, x_ref, u_ref); % Technically should pass in delta_t too but just scales objective function...
    end
end

% Convert solution to Matlab friendly types
solve_status = "NOT IMPLEMENTED";
if solve_status == "0 (for description visit https://github.com/embotech/ecos/wiki/Usage-from-C)"
    solve_status = "Optimal solution";
end

if solve_status ~= "infeasible"
    v_prime = [];
else
    X = x_ref;
    U = u_ref;
    p = p_ref;
    eta = [];
    V = [];
    v_prime = [];
    v_0 = [];
    v_N = [];
end

t2 = toc(t1);

% Package outputs

x_sol = X;
u_sol = U;
p_sol = p;
%fprintf("CVXPY Time: %.3f ms\n", t2 * 1000 )
sol_info.status = solve_status;
if solve_status ~= "infeasible"
    sol_info.vd = V;
    sol_info.vs = v_prime;
    sol_info.vbc_0 = v_0;
    sol_info.vbc_N = v_N;
    sol_info.J = prob.objective(prob.unscale_x(X), prob.unscale_u(U), prob.unscale_p(p));
    sol_info.J_tr = trust_region_cost(eta, 0, ptr_ops.w_tr, 0);
    sol_info.J_vc = virtual_control_cost(V, v_prime, v_0, v_N, ptr_ops.w_vc);
    sol_info.dJ = 100 * (prob.objective(prob.unscale_x(X), prob.unscale_u(U), 0) - prob.objective(prob.unscale_x(x_ref), prob.unscale_u(u_ref), 0)) / prob.objective(prob.unscale_x(x_ref), prob.unscale_u(u_ref), 0);
    sol_info.dx = vecnorm(X(:, 1:prob.Nu) - x_ref(:, 1:prob.Nu), ptr_ops.q, 1);
    sol_info.du = vecnorm(U - u_ref, ptr_ops.q, 1);
    sol_info.dp = vecnorm(p - p_ref, ptr_ops.q, 1);
    sol_info.eta = eta;
    sol_info.eta_x = 0;
    sol_info.eta_u = 0;
    sol_info.eta_p = 0;
else
    sol_info.vd = 0;
    sol_info.vs = 0;
    sol_info.vbc_0 = 0;
    sol_info.vbc_N = 0;
    sol_info.J = 0;
    sol_info.J_tr = 0;
    sol_info.J_vc = 0;
    sol_info.dJ = 0;
    sol_info.dx = 0;
    sol_info.du = 0;
    sol_info.dp = 0;
    sol_info.eta = 0;
    sol_info.eta_x = 0;
    sol_info.eta_u = 0;
    sol_info.eta_p = 0;
end
end

function [J_tr] = trust_region_cost(eta, eta_p, w_tr, w_tr_p)
    J_tr = w_tr * eta' + w_tr_p * eta_p;
end

function [J_vc] = virtual_control_cost(V, v_prime, v_0, v_N, w_vc)
    J_vc = w_vc * (norm(v_prime, 1) + sum(norms(V, 1, 1)) + norm(v_0, 1) + norm(v_N, 1));
end

